# This function is used when several MCMC have been run in MCMCtree
# and there is a need to generate a consensus FigTree.tre file.
# The input files needed are generated by the "Get_summary_trees.sh" bash script,
# which needs to be run in the directory where the results for the several
# MCMC runs are.
# ============================ #
# EXAMPLE OF FILE ARCHITECTURE #
# ============================ #
#   main_dir 
#         |- tree_files # Dir where "Get_summary_trees.sh" will save output files
#         |             # used as input files here. The path to this directory
#         |             # will be the first argument of "summ_trees"
#         |- run1
#         |     |- mcmc1
#         |     |     |- mcmctree_GBM # Directory where "out.txt" file is
#         |     |     |- mcmctree_ILN # Directory where "out.txt" file is
#         |     |- mcmc2
#         |
#         |- ...
#         |- runX 
#
#
# The function "summ_trees" only needs two arguments:
#    runs Integer, number of runs (i.e., number of "runX" directories, where X = runs )
#    path Character, vector containing the path to the "tree_files" directory where 
#         all the input files needed to output the combined FigTree.tre are. 

summ_trees <- function( runs, path ){ 
  
  # 1. Get tree files from each run to average the branch lengths
  n <- runs 
  trees.list          <- out.list <- vector( mode = "list", n )
  names( trees.list ) <- names( out.list ) <- paste( "run_", seq(1:n), sep = "" )
  trees.names         <- list.files( path, pattern = "_[0-9].tree" )
  out.divt            <- list.files( path, pattern = "_[0-9].txt" )
  tree.nodepos        <- list.files( path, pattern = "indbl" ) 
  tree.divt.filt      <- list.files( path, pattern = "tmp_tree_divtimes_filt" )
  equal.upndown       <- 0
    
  # 2. Read trees and out.txt for each run
  for( i in 1:n ){
    # Save tree
    trees.list[[ i ]] <- ape::read.tree( file = paste( path, trees.names[i], sep = "" ) )
    out.list[[ i ]]   <- read.table( file = paste( path, out.divt[i], sep = "" ),
                                     sep = "\t", stringsAsFactors = F )
    if( i == 1 ){
      # Create object class matrix to save blengths
      num.bl                   <- length( trees.list[[ i ]]$edge.length )
      blengths.mat             <- matrix( 0, nrow = n, ncol = num.bl )
      rownames( blengths.mat ) <- paste( "run", 1:n, sep = "" )
      
      # Create object class matrix to save CI.up and CI.down
      num.CI                   <- length( out.list[[ i ]][,1] )
      CIup.mat <- CIdown.mat   <- matrix( 0, nrow = n, ncol = num.CI )
      rownames( CIup.mat )     <- rownames( CIdown.mat ) <- paste( "run", 1:n, sep = "" )
      colnames( CIup.mat )     <- colnames( CIdown.mat ) <- out.list[[ i ]][,1]
    }
    
    blengths.mat[i,]  <- trees.list[[ i ]]$edge.length
    CIdown.mat[i,]    <- out.list[[ i ]][,3]
    CIup.mat[i,]      <- out.list[[ i ]][,4]
    
  }
  
  # 3. Get mean branch lengths, mean CI.up, and mean CI.down
  mean.blengths <- apply( blengths.mat, 2, mean )
  #>> CHECK 
  #> mean.blengths[1]         # 1.463877
  #> mean( blengths.mat[,1] ) # 1.704129
  #>> OK!
  mean.CIdown   <- apply( CIdown.mat, 2, mean )
  #>> CHECK 
  #> mean.CIdown[1]         # 1.704129
  #> mean( CIdown.mat[,1] ) # 1.463877
  #>> OK!
  mean.CIup     <- apply( CIup.mat, 2, mean )
  #>> CHECK 
  #> mean.CIup[1]         # 2.545886 
  #> mean( CIup.mat[,1] ) # 2.545886
  #>> OK!
  mean.CIs      <- paste( round( mean.CIdown, 4 ),
                          round( mean.CIup, 4 ), sep = ", "  )
  names( mean.CIs ) <- gsub( pattern = "t_n", replacement = "", x = names( mean.CIup ) )
  
  # 4. Get tmp tree file to find position where to replace quantiles
  tmp.tree        <- readLines( paste( path, tree.divt.filt, sep = "" ) )
  tmp.tree        <- tmp.tree[[1]]
  ind.file        <- gsub( pattern = "..*_", replacement = "", x = tree.divt.filt )
  ind.file        <- as.numeric( gsub( pattern = ".tree", replacement = "", x = ind.file ) )
  tmp.tree2       <- trees.list[[ ind.file ]]
  tmp.tree.noCIs  <- tmp.tree
  tmp.treenodes   <- ape::read.tree( file = paste( path, tree.nodepos, sep = "" ) )

  # 5. Get ordered CIs 
  CIs.raw      <- strsplit( x = tmp.tree, split = "\"" )[[1]]
  vals.extract <- seq( 2, dim( blengths.mat)[[2]], by = 2 )
  CIs          <- CIs.raw[ vals.extract ]
  
  # 6. Get CIs from the tmp out.txt files that was used to generate the tree.divt.filt file
  #    when using the "Get_summary.tree.sh" script
  tmp.divt <- read.table( file = paste( path, out.divt[ ind.file ], sep = "" ),
                          sep = "\t", stringsAsFactors = F )
  colnames( tmp.divt )   <- c( "node", "mean_t", "CIlow", "CIup" )
  match.divt             <- matrix( 0, nrow = dim( tmp.divt )[1], ncol = 2 )
  colnames( match.divt ) <- c( "pos.CI.outf", "pos.CI.tree" )
  
  # 7. Match positions of quantiles in tree with the mean times and quantiles 
  #    in the outfile
  for( j in 1:length( CIs ) ){
    
    # 7.1. Get numeric values for mean times and mean quantiles
    CI95.noround <- as.numeric( strsplit( x = CIs[j], ", " )[[1]] )
    CI95  <- round( as.numeric( strsplit( x = CIs[j], ", " )[[1]] ), 4 )
    lowCI <- CI95[1]
    upCI  <- CI95[2]
    
    # 7.2. Find position of upper and lower CI in tree and out files
    ind.pos.low <- which( tmp.divt[,3] == lowCI )
    decimal.val <- 4
    while( length( ind.pos.low ) == 0 ){
      decimal.val   <- decimal.val - 1 
      tmp.val.round <- round( tmp.divt[,3], decimal.val )
      tmp.CI.round  <- round( lowCI, decimal.val )
      ind.pos.low   <- which( tmp.val.round == tmp.CI.round )
    }
    ind.pos.up  <- which( tmp.divt[,4] == upCI )
    decimal.val <- 4
    while( length( ind.pos.up ) == 0 ){
      decimal.val   <- decimal.val - 1 
      tmp.val.round <- round( tmp.divt[,4], decimal.val )
      tmp.CI.round  <- round( upCI, decimal.val )
      ind.pos.up    <- which( tmp.val.round == tmp.CI.round )
    }
    # Check there is no coincidence with the CIs in more than one node
    if( length( ind.pos.low ) > 1 & length( ind.pos.up ) == 1 ){
      ind.pos.low <- ind.pos.up
    }else if( length( ind.pos.low ) == 1 & length( ind.pos.up ) > 1 ){
      ind.pos.up <- ind.pos.low
    }else if( length( ind.pos.low ) > 1 & length( ind.pos.up ) > 1 ){
      # cat( "low : ",ind.pos.low, " | up: ", ind.pos.up, "\n" )
      write( c( "low:" ),
             file = paste( path, "log_possible_nodes_conflict.txt", sep = "" ),
             append = TRUE )
      write( as.character( ind.pos.low ),
             file = paste( path, "log_possible_nodes_conflict.txt", sep = "" ),
             append = TRUE )
      write( c( "up:" ),
             file = paste( path, "log_possible_nodes_conflict.txt", sep = "" ),
             append = TRUE )
      write( as.character( ind.pos.up ),
             file = paste( path, "log_possible_nodes_conflict.txt", sep = "" ),
             append = TRUE )
      tmp.pos     <- intersect( ind.pos.low, ind.pos.up )
      ind.pos.low <- tmp.pos
      ind.pos.up  <- tmp.pos
      
      ## THIS DOES NOT WORK!!-----##
      # if( all.equal( ind.pos.low, ind.pos.up ) == TRUE ){
      #   equal.upndown <- equal.upndown + 1 
      #   ind.pos.low <- ind.pos.up <- tmp.pos[equal.upndown]
      #   write( c( "ind.pos.low == ind.pos.up, so we got position ", equal.upndown, "for now!" ),
      #          file = paste( path, "log_possible_nodes_conflict.txt", sep = "" ),
      #          append = TRUE )
      # }
      ##--------------------------##
        
      # cat( "kept: ", tmp.pos, "\nCHECK NODE", tmp.divt[tmp.pos,1],
           # "THERE SEEMS TO BE CONFLICT. J is ", j, "\n\n" )
      write( paste( "\nkept: ", tmp.pos, "\nCHECK NODE", tmp.divt[tmp.pos,1],
                    ". THERE SEEMS TO BE CONFLICT. J is ", j, "\n\n", sep = "" ),
             file = paste( path, "log_possible_nodes_conflict.txt", sep = "" ),
             append = TRUE )
    }else if( length( ind.pos.low ) == 1 & length( ind.pos.up ) == 1 ){
    }else{
      stop( "There is a conflict with one of the nodes. Check out.txt" )
    }
    # This is final position !
    ind.pos         <- as.numeric( unique( ind.pos.low, ind.pos.up ) )
    print( ind.pos )
    # Save final position and "j" in array
    if( length( ind.pos ) > 1 ){
      cat( "This position is matched in indexes ", ind.pos, "!! \n" )
      ind.pos <- paste0( ind.pos, collapse = "|")
    }
    match.divt[j,1] <- ind.pos
    match.divt[j,2] <- j
    
    cat( "95%CI for node ", ind.pos, " , with mean t = ", tmp.divt[ind.pos,2],
         " and CI of ", tmp.divt[ind.pos,3], " - ", tmp.divt[ind.pos,4],
         ", in tree file is pos ",
         j, "\n" )
    
    # 7.3. Check positions found before to match pos in tree
    ##>> CHECK
    # pos.tree     <- 1
    # pos.node.out <- match.divt[ which( match.divt[,2] == pos.tree ), 1 ]
    # tmp.node    <- c( tmp.outdivt[pos.node.out,3], tmp.outdivt[pos.node.out,4] )
    # 
    # tmp.CIs.round <- round( as.numeric( strsplit( CIs.1[pos.tree], split = ", " )[[1]] ), 4 )
    # 
    # all.equal( tmp.node,tmp.CIs.round )
    # 
    # pos.tree     <- 14
    # pos.node.out <- match.divt[ which( match.divt[,2] == pos.tree ), 1 ]
    # tmp.node     <- c( tmp.outdivt[pos.node.out,3], tmp.outdivt[pos.node.out,4] )
    # 
    # tmp.CIs.round <- round( as.numeric( strsplit( CIs.1[pos.tree], split = ", " )[[1]] ), 4 )
    # 
    # all.equal( tmp.node,tmp.CIs.round )
    ##>> END CHECK, SUCCESS !
    
    
    # 7.4. Replace in correct position of tree the CI for the mean CI 
    #      averaged across all MCMCs
    # Format wanted: [&95%={X, Y}]
    tmp.tree.check <- tmp.tree
    tmp.tree <- gsub( pattern = paste( "\\\"", CIs[j], "\\\"", sep = "" ),
                      replacement = paste( "[&95%={", mean.CIs[ind.pos], "}]", sep = "" ),
                      x = tmp.tree )
    
    tmp.tree.noCIs <- gsub( pattern = paste( "\\\"", CIs[j], "\\\"", sep = "" ),
                            replacement = "", x = tmp.tree.noCIs )
    if( all.equal( tmp.tree, tmp.tree.check ) == TRUE ){
      stop( "There is something that has had issues being replaced with the 95% CI !" )
    }
    
  }
  
  # Check those indexes that are repeated because of being the same CI 
  ind.same.CI   <- grep( "\\|", x = match.divt[,1] )
  vals.same.CI  <- match.divt[ind.same.CI,1]
  visited.CIs   <- vector( mode = "numeric", length( ind.same.CI ) )
  match.divt.cp <- match.divt
  for( i in 1:length( ind.same.CI ) ){
    
    if( match.divt[ ind.same.CI[i],1 ] %in% visited.CIs ){
      # Replace position with the oldest!
      tmp.old <- sort( as.numeric( strsplit( x = match.divt[ ind.same.CI[i],1 ], split = "\\|" )[[1]] ) )
      match.divt.cp[ ind.same.CI[i],1 ]  <- as.character( tmp.old[2] )
      # cat( match.divt[ ind.same.CI[i],1 ], "---", tmp.same.CI[2], "\n" )
      cat( "OLD\n" )
    }else{
      tmp.young <- sort( as.numeric( strsplit( x = match.divt[ ind.same.CI[i],1 ], split = "\\|" )[[1]] ) )
      # Replace position with the youngest!
      match.divt.cp[ ind.same.CI[i],1 ]  <- as.character( tmp.young[1] )
      # cat( match.divt[ ind.same.CI[i],1 ], "---", tmp.same.CI[1], "\n" )
      cat( "YOUNG\n" )
    }
    # Account for those visited!
    visited.CIs[ i ] <- match.divt[ ind.same.CI[i],1 ]
  }
  # Update
  match.divt <- match.divt.cp
  
  # Update branch lengths 
  final.tree    <- tmp.tree
  count.matches <- 0 
  for( i in tmp.tree2$edge.length ){
      a <- which( tmp.tree2$edge.length == i )
      if( length( a ) > 1 ){
        print( a )
      }
  }
  
  
  for( blength in length( tmp.tree2$edge.length ):1 ){
    write( paste( "Replace ", tmp.tree2$edge.length[blength], " with mean bl = ", 
                  mean.blengths[blength], "\n", sep = "" ),
           file = paste( path, "log_replace_bl.txt", sep = "" ),
           append = TRUE )
    final.tree <- gsub( pattern = format( round( tmp.tree2$edge.length[blength], 8 ),
                                          nsmall = 6 ),
                    replacement = as.character( mean.blengths[blength] ),
                    x = final.tree )
    # Check everything has been replaced !
    a <- stringi::stri_detect_fixed( str = final.tree, 
                                     pattern = as.character( mean.blengths[blength] ) )
    if( a == TRUE ){
      count.matches <- count.matches + 1
      a <- NULL
    }else{
      print( a )
      print( blength )
      print( format( round( tmp.tree2$edge.length[blength], 8 ) , nsmall = 6 ) )
      print( as.character( mean.blengths[blength] ) )
    }
  }
  write.table( x = match.divt, file = paste( path, "match_divt.csv", sep = "" ),
               quote = FALSE, row.names = FALSE )
  
  # 8. Print visual spaces to separate one dir from another
  cat( "\n\n" )
  
  # 9. Write tmp tree file that will be later read to modify the blenghts
  #    and add the mean blenghts previously calculated 
  write( x = final.tree, file = paste( path, "FigTree_comb_raw.tree", sep = "" ) )

  ## OLD -- NOT USED ANYMORE -- ##
  # 10. Read tree with ape and change blenghts
  # tmp.tree2        <- ape::read.tree( paste( path, "FigTree_comb_raw.tree", sep = "" ) )
  # final.tree       <- tmp.tree
  # 
  # for( blength in 1:length( tmp.tree2$edge.length ) ){
  #   write( paste( "Replace ", tmp.tree2$edge.length[blength], " with mean bl = ", 
  #                 mean.blengths[blength], "\n", sep = "" ),
  #          file = paste( path, "log_replace_bl.txt", sep = "" ),
  #          append = TRUE )
  #   final.tree <- gsub( pattern = tmp.tree2$edge.length[blength],
  #                       replacement = as.character( mean.blengths[blength] ),
  #                       x = final.tree )
  #   
  # }
  ## -------- ##
  
  # 11. Write down the tree !
  text1 <- c( "#NEXUS\nBEGIN TREES;\n\n\tUTREE 1 = " )
  text2 <- c( "\n\nEND;\n" )
  nexus.tree <- paste( text1, final.tree, text2, sep = "" )

  write( x = nexus.tree, file = paste( path, "FigTree_comb.tree", sep = "" ) )

}
